---
title: "TypeScript 제네릭 완전 정복"
description: "제네릭의 기초부터 조건부 타입, infer까지. 실무에서 자주 쓰는 제네릭 패턴을 정리합니다."
date: "2026-02-06"
category: "Frontend"
tags: ["typescript", "generics", "frontend"]
thumbnail: "/images/posts/typescript-generics.svg"
---

## 제네릭이란?

제네릭은 **타입을 매개변수화**하여 재사용 가능한 컴포넌트를 만드는 기능입니다.

```typescript
// 제네릭 없이
function identity(arg: number): number {
  return arg;
}

// 제네릭으로
function identity<T>(arg: T): T {
  return arg;
}

identity<string>("hello"); // 타입: string
identity(42);              // 타입 추론: number
```

## 제네릭 제약 조건

`extends` 키워드로 타입 매개변수를 제한할 수 있습니다.

```typescript
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength("hello");     // OK
logLength([1, 2, 3]);   // OK
logLength(123);          // Error: number에는 length가 없음
```

## 실전 패턴

### API 응답 래퍼

```typescript
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

async function fetchUser(): Promise<ApiResponse<User>> {
  const res = await fetch("/api/user");
  return res.json();
}
```

### 조건부 타입

```typescript
type IsString<T> = T extends string ? "yes" : "no";

type A = IsString<string>;  // "yes"
type B = IsString<number>;  // "no"
```

### keyof와 인덱스 접근

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Kim", age: 25 };
getProperty(user, "name"); // 타입: string
getProperty(user, "age");  // 타입: number
```

## 정리

- **기본 제네릭**: `<T>` 로 타입 매개변수 선언
- **제약 조건**: `extends`로 타입 범위 제한
- **조건부 타입**: 타입 레벨 분기 처리
- **keyof + 인덱스**: 객체 타입에서 안전한 접근
